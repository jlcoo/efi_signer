use efi_signer::EfiImage;
use picky::x509::pkcs7::Pkcs7;

pub fn init() {
    let _ = env_logger::builder().is_test(true).try_init();
}

#[test]
fn test_sign() {
    init();
    let pem = include_bytes!("./certificate.pem");
    let p7 = EfiImage::pem_to_p7(pem).unwrap();
    let p7_str = String::from_utf8(p7).unwrap();
    let ip7 = Pkcs7::from_pem_str(&p7_str).unwrap();

    let origin_p7 = include_bytes!("./certificate.p7b");
    let origin_str = String::from_utf8(origin_p7.to_vec()).unwrap();
    let origin_ip7 = Pkcs7::from_pem_str(&origin_str).unwrap();

    assert_eq!(ip7.digest_algorithms(), origin_ip7.digest_algorithms());
    assert_eq!(ip7.decode_certificates(), origin_ip7.decode_certificates());
    assert_eq!(ip7.signer_infos(), origin_ip7.signer_infos());
    // p7b generated by openssl with a 0 in crl contentInfo as with then openssl rust API, wo got a absence crl
    // so the contentInfo will differ literally but i think they are the same
    //assert_eq!(ip7.encapsulated_content_info(), origin_ip7.encapsulated_content_info());
    //assert_eq!(ip7.to_der().unwrap(), origin_ip7.to_der().unwrap());
}
